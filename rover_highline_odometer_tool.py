#!/usr/bin/env python3
"""
Rover 75 & MG ZT Highline Odometer Correction

Single-file Windows GUI utility (Tkinter).

Functionality:
- Open a donor EEPROM (.bin) of the HIGHLINE IPK (256 bytes expected)
- Read the stored odometer value from offset 0x18..0x1A (3 bytes little-endian)
  using the discovered formula: stored = km * 25 + 371
- Display current odometer in KM and MILES
- Allow user to enter desired odometer (miles or km)
- Convert and show resulting stored bytes
- Optionally search for and update mirrored occurrences of the raw 3-byte stored value
- Save the modified EEPROM with "Save As"

Usage:
1. Run on Windows: `python rover_highline_odometer_tool.py`
2. Click "Open EEPROM" and choose the highline .bin file
3. Current odometer will display. Enter the new value and select unit.
4. Click "Apply" then "Save As" to export a modified file.

Notes and disclaimers:
- This tool assumes the HIGHLINE layout where odometer is at 0x18..0x1A and
  encoded as: stored = km * 25 + 371, stored as 3-byte little-endian.
- Use at your own risk. Always keep original backups and verify before flashing.

Author: Generated by ChatGPT for user
"""

import struct
import tkinter as tk
from tkinter import filedialog, messagebox
from tkinter import ttk
import os

# Constants
OFFSET = 0x18
LENGTH = 3
KM_OFFSET_CONST = 371
KM_SCALE = 25
KM_PER_MILE = 1.609344

# Helpers

def read_eeprom(path):
    with open(path, "rb") as f:
        data = f.read()
    return bytearray(data)


def write_eeprom(path, data):
    with open(path, "wb") as f:
        f.write(data)


def stored_bytes_to_int(bts):
    # 3-byte little-endian
    if len(bts) != 3:
        raise ValueError("stored bytes must be length 3")
    return int.from_bytes(bts, 'little')


def int_to_stored_bytes(value):
    return value.to_bytes(3, 'little')


def km_from_stored(stored_value):
    return (stored_value - KM_OFFSET_CONST) / KM_SCALE


def stored_from_km(km):
    # round to integer stored value
    stored = int(round(km * KM_SCALE + KM_OFFSET_CONST))
    return stored


def miles_to_km(miles):
    return miles * KM_PER_MILE


def km_to_miles(km):
    return km / KM_PER_MILE


# GUI Application
class OdometerApp(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title("Rover 75 & MGZT Highline Odometer Correction")
        self.geometry("640x380")
        self.resizable(False, False)

        self.eeprom_data = None
        self.eeprom_path = None
        self.original_stored_bytes = None

        self.create_widgets()

    def create_widgets(self):
        pad = 8

        frame_top = ttk.Frame(self)
        frame_top.pack(fill='x', padx=pad, pady=pad)

        btn_open = ttk.Button(frame_top, text="Open EEPROM", command=self.open_eeprom)
        btn_open.grid(row=0, column=0, sticky='w')

        self.lbl_path = ttk.Label(frame_top, text="No file loaded", width=70)
        self.lbl_path.grid(row=0, column=1, padx=10, sticky='w')

        separator = ttk.Separator(self, orient='horizontal')
        separator.pack(fill='x', padx=pad, pady=(0, pad))

        frame_info = ttk.Frame(self)
        frame_info.pack(fill='x', padx=pad)

        ttk.Label(frame_info, text="Detected stored bytes (hex):").grid(row=0, column=0, sticky='w')
        self.var_stored_hex = tk.StringVar(value="--")
        ttk.Label(frame_info, textvariable=self.var_stored_hex).grid(row=0, column=1, sticky='w')

        ttk.Label(frame_info, text="Stored value (decimal):").grid(row=1, column=0, sticky='w')
        self.var_stored_dec = tk.StringVar(value="--")
        ttk.Label(frame_info, textvariable=self.var_stored_dec).grid(row=1, column=1, sticky='w')

        ttk.Label(frame_info, text="Decoded odometer (km):").grid(row=2, column=0, sticky='w')
        self.var_km = tk.StringVar(value="--")
        ttk.Label(frame_info, textvariable=self.var_km).grid(row=2, column=1, sticky='w')

        ttk.Label(frame_info, text="Decoded odometer (miles):").grid(row=3, column=0, sticky='w')
        self.var_miles = tk.StringVar(value="--")
        ttk.Label(frame_info, textvariable=self.var_miles).grid(row=3, column=1, sticky='w')

        # Input section
        separator2 = ttk.Separator(self, orient='horizontal')
        separator2.pack(fill='x', padx=pad, pady=(pad, pad))

        frame_input = ttk.Frame(self)
        frame_input.pack(fill='x', padx=pad)

        ttk.Label(frame_input, text="Enter desired odometer:").grid(row=0, column=0, sticky='w')
        self.entry_value = ttk.Entry(frame_input, width=20)
        self.entry_value.grid(row=0, column=1, sticky='w')

        self.unit_var = tk.StringVar(value='miles')
        ttk.Radiobutton(frame_input, text='Miles', variable=self.unit_var, value='miles', command=self.on_unit_change).grid(row=0, column=2, padx=6)
        ttk.Radiobutton(frame_input, text='Kilometres', variable=self.unit_var, value='km', command=self.on_unit_change).grid(row=0, column=3, padx=6)

        ttk.Label(frame_input, text="(integers recommended)").grid(row=0, column=4, sticky='w')

        self.btn_apply = ttk.Button(frame_input, text="Apply", command=self.apply_value)
        self.btn_apply.grid(row=0, column=5, padx=10)

        # Mirror option
        self.mirror_var = tk.BooleanVar(value=True)
        ttk.Checkbutton(self, text="Update mirrored occurrences of the 3-byte stored value", variable=self.mirror_var).pack(anchor='w', padx=pad)

        # Save button
        frame_save = ttk.Frame(self)
        frame_save.pack(fill='x', padx=pad, pady=(10,0))

        self.btn_save = ttk.Button(frame_save, text="Save As...", command=self.save_as)
        self.btn_save.grid(row=0, column=0, sticky='w')

        self.lbl_status = ttk.Label(frame_save, text="Status: Ready")
        self.lbl_status.grid(row=0, column=1, sticky='w', padx=10)

    def open_eeprom(self):
        path = filedialog.askopenfilename(title="Open EEPROM file", filetypes=[("Binary files","*.bin;*.eep;*.*")])
        if not path:
            return
        try:
            data = read_eeprom(path)
        except Exception as e:
            messagebox.showerror("Error", f"Failed to open file: {e}")
            return
        self.eeprom_data = data
        self.eeprom_path = path
        self.lbl_path.config(text=os.path.basename(path))
        self.lbl_status.config(text="Status: File loaded")
        self.read_odometer()

    def read_odometer(self):
        if self.eeprom_data is None:
            return
        if len(self.eeprom_data) < OFFSET + LENGTH:
            messagebox.showerror("Error", "EEPROM file too small or unexpected format")
            return
        bts = bytes(self.eeprom_data[OFFSET:OFFSET+LENGTH])
        self.original_stored_bytes = bts
        stored_val = stored_bytes_to_int(bts)
        try:
            km = km_from_stored(stored_val)
            miles = km_to_miles(km)
            # Format
            self.var_stored_hex.set(bts.hex().upper())
            self.var_stored_dec.set(str(stored_val))
            self.var_km.set(f"{km:,.2f}")
            self.var_miles.set(f"{miles:,.2f}")
            self.lbl_status.config(text="Status: Odometer read")
        except Exception as e:
            messagebox.showerror("Decode error", f"Failed to decode odometer: {e}")

    def on_unit_change(self):
        # no-op placeholder (could convert current entry)
        pass

    def apply_value(self):
        if self.eeprom_data is None:
            messagebox.showwarning("No file", "Open an EEPROM file first")
            return
        val_text = self.entry_value.get().strip()
        if not val_text:
            messagebox.showwarning("Input", "Enter a desired odometer value")
            return
        try:
            # allow floats, but they'll be rounded into km
            val = float(val_text)
        except ValueError:
            messagebox.showerror("Input error", "Enter a numeric value (no commas)")
            return
        # Convert to km if needed
        if self.unit_var.get() == 'miles':
            km = miles_to_km(val)
        else:
            km = val
        if km < 0:
            messagebox.showerror("Input error", "Negative odometer not allowed")
            return
        # Prepare stored value
        stored_val = stored_from_km(km)
        new_bytes = int_to_stored_bytes(stored_val)

        # Update primary location
        self.eeprom_data[OFFSET:OFFSET+LENGTH] = new_bytes

        # Optionally update mirrors (exact byte matches of the original 3-byte sequence)
        mirrors_updated = 0
        if self.mirror_var.get() and self.original_stored_bytes is not None:
            orig = self.original_stored_bytes
            new = new_bytes
            for i in range(len(self.eeprom_data)-LENGTH+1):
                if bytes(self.eeprom_data[i:i+LENGTH]) == orig:
                    # skip primary location (already updated)
                    if i == OFFSET:
                        continue
                    self.eeprom_data[i:i+LENGTH] = new
                    mirrors_updated += 1

        # Refresh display
        self.read_odometer()

        msg = f"Applied new value. Stored value = {stored_val} (hex {new_bytes.hex().upper()})."
        if mirrors_updated:
            msg += f" Updated {mirrors_updated} mirrored occurrence(s)."
        messagebox.showinfo("Applied", msg)
        self.lbl_status.config(text="Status: Changes applied (unsaved)")

    def save_as(self):
        if self.eeprom_data is None:
            messagebox.showwarning("No file", "Open an EEPROM file first")
            return
        path = filedialog.asksaveasfilename(title="Save modified EEPROM as...", defaultextension='.bin', filetypes=[('Binary file','*.bin')])
        if not path:
            return
        try:
            write_eeprom(path, self.eeprom_data)
        except Exception as e:
            messagebox.showerror("Error", f"Failed to save file: {e}")
            return
        messagebox.showinfo("Saved", f"File saved: {os.path.basename(path)}")
        self.lbl_status.config(text=f"Status: Saved to {os.path.basename(path)}")


if __name__ == '__main__':
    app = OdometerApp()
    app.mainloop()
